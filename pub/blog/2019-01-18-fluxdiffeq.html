<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>DiffEqFlux.jl – A Julia Library for Neural Differential Equations</title>
  <meta name="author" content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al." />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Official website for the Julia programming language. Join the Julia community today.">

  <meta property="og:title" content="The Julia Language"/>
  <meta property="og:image" content="http://www.julialang.org/images/julia-open-graph.png"/>
  <meta property="og:description" content="Official website for the Julia programming language"/>

   <!-- Un-minified script so that can play a bit -->
<link rel="stylesheet" href="/libs/katex/katex.min.css">
     
   <!-- Syntax highlighting via Prism, note: restricted langs -->
<link rel="stylesheet" href="/libs/highlight/github.min.css">
   
  

  <link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel="stylesheet">
  <link rel="stylesheet" href="/assets/v2/css/bootstrap.min.css" />
  <link rel="stylesheet" href="/assets/v2/css/app.css" />
  <link rel="stylesheet" href="/assets/v2/css/fonts.css" />
  <link rel="stylesheet" href="/assets/v2/css/highlight/github.css" />

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-28835595-1');
</script>

</head>

<body>

<div class="jd-content">
<p>Translations:  <a href="https://julialang.org/blog/2019/04/fluxdiffeq-zh_tw">Traditional Chinese</a>
<p>In this blog post we will show you how to easily, efficiently, and robustly use differential equation &#40;DiffEq&#41; solvers with neural networks in Julia.</p>
<p><img src="https://user-images.githubusercontent.com/1814174/51399500-1f4dd080-1b14-11e9-8c9d-144f93b6eac2.gif" alt="Flux ODE Training Animation" /></p>
<p>The <a href="https://arxiv.org/abs/1806.07366">Neural Ordinary Differential Equations</a> paper has attracted significant attention even before it was awarded one of the Best Papers of NeurIPS 2018. The paper already gives many exciting results combining these two disparate fields, but this is only the beginning: neural networks and differential equations were born to be together. This blog post, a collaboration between authors of <a href="https://github.com/FluxML/Flux.jl">Flux</a>, <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a> and the Neural ODEs paper, will explain why, outline current and future directions for this work, and start to give a sense of what&#39;s possible with state-of-the-art tools.</p>
<p>The advantages of the Julia <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a> library for numerically solving differential equations have been <a href="http://www.stochasticlifestyle.com/comparison-differential-equation-solver-suites-matlab-r-julia-python-c-fortran/">discussed in detail in other posts</a>. Along with its <a href="https://github.com/JuliaDiffEq/DiffEqBenchmarks.jl">extensive benchmarking against classic Fortran methods</a>, it includes other modern features such as <a href="http://www.stochasticlifestyle.com/solving-systems-stochastic-pdes-using-gpus-julia/">GPU acceleration</a>, <a href="http://docs.juliadiffeq.org/latest/features/monte_carlo.html">distributed &#40;multi-node&#41; parallelism</a>, and <a href="http://docs.juliadiffeq.org/latest/features/callback_functions.html">sophisticated event handling</a>. Recently, these native Julia differential equation solvers have successfully been embedded into the <a href="https://github.com/FluxML/Flux.jl/">Flux</a> deep learning package, to allow the use of a full suite of highly tested and optimized DiffEq methods within neural networks. Using the new package <a href="https://github.com/JuliaDiffEq/DiffEqFlux.jl/">DiffEqFlux.jl</a>, we will show the reader how to easily add differential equation layers to neural networks using a range of differential equations models, including stiff ordinary differential equations, stochastic differential equations, delay differential equations, and hybrid &#40;discontinuous&#41; differential equations.</p>
<p>This is the first toolbox to combine a fully-featured differential equations solver library and neural networks seamlessly together. The blog post will also show why the flexibility of a full differential equation solver suite is necessary. With the ability to fuse neural networks with ODEs, SDEs, DAEs, DDEs, stiff equations, and different methods for adjoint sensitivity calculations, this is a large generalization of the neural ODEs work and will allow researchers to better explore the problem domain.</p>
<p>&#40;Note: If you are interested in this work and are an undergraduate or graduate student, we have <a href="https://julialang.org/soc/ideas-page">Google Summer of Code projects available in this area</a>. This <a href="https://developers.google.com/open-source/gsoc/help/student-stipends">pays quite well over the summer</a>. Please join the <a href="https://slackinvite.julialang.org/">Julia Slack</a> and the #jsoc channel to discuss in more detail.&#41;</p>
<div class="jd-toc"><ol><li><a href="/pub/blog/2019-01-18-fluxdiffeq.html#what_do_differential_equations_have_to_do_with_machine_learning">What do differential equations have to do with machine learning?</a></li><li><a href="/pub/blog/2019-01-18-fluxdiffeq.html#what_is_the_neural_ordinary_differential_equation_ode">What is the Neural Ordinary Differential Equation &#40;ODE&#41;?</a></li><li><a href="/pub/blog/2019-01-18-fluxdiffeq.html#how_do_you_solve_an_ode">How do you solve an ODE?</a></li><li><a href="/pub/blog/2019-01-18-fluxdiffeq.html#lets_put_an_ode_into_a_neural_net_framework">Let&#39;s Put an ODE Into a Neural Net Framework&#33;</a></li><li><a href="/pub/blog/2019-01-18-fluxdiffeq.html#why_is_a_full_ode_solver_suite_necessary_for_doing_this_well">Why is a full ODE solver suite necessary for doing this well?</a></li><li><a href="/pub/blog/2019-01-18-fluxdiffeq.html#what_kinds_of_differential_equations_are_there">What kinds of differential equations are there?</a></li><li><a href="/pub/blog/2019-01-18-fluxdiffeq.html#implementing_the_neural_ode_layer_in_julia">Implementing the Neural ODE layer in Julia</a></li><li><a href="/pub/blog/2019-01-18-fluxdiffeq.html#understanding_the_neural_ode_layer_behavior_by_example">Understanding the Neural ODE layer behavior by example</a></li><li><a href="/pub/blog/2019-01-18-fluxdiffeq.html#the_core_technical_challenge_backpropagation_through_differential_equation_solvers">The core technical challenge: backpropagation through differential equation solvers</a></li><li><a href="/pub/blog/2019-01-18-fluxdiffeq.html#conclusion">Conclusion</a></li></ol></div>
<h2 id="what_do_differential_equations_have_to_do_with_machine_learning"><a href="/pub/blog/2019-01-18-fluxdiffeq.html#what_do_differential_equations_have_to_do_with_machine_learning">What do differential equations have to do with machine learning?</a></h2>
<p>The first question someone not familiar with the field might ask is, why are differential equations important in this context? The simple answer is that a differential equation is a way to specify an arbitrary nonlinear transform by mathematically encoding prior structural assumptions.</p>
<p>Let&#39;s unpack that statement a bit. There are three common ways to define a nonlinear transform: direct modeling, machine learning, and differential equations. Directly writing down the nonlinear function only works if you know the exact functional form that relates the input to the output. However, in many cases, such exact relations are not known <em>a priori</em>. So how do you do nonlinear modeling if you don&#39;t know the nonlinearity?</p>
<p>One way to address this is to use machine learning. In a typical machine learning problem, you are given some input \(x\) and you want to predict an output \(y\). This generation of a prediction \(y\) from \(x\) is a machine learning model &#40;let&#39;s call it \(ML\)&#41;.  During training, we attempt to adjust the parameters of \(ML\) so that it generates accurate predictions.  We can then use \(ML\) for inference &#40;i.e., produce \(y\)s for novel inputs \(x\)&#41;. This is just a nonlinear transformation \(y=ML(x)\). The reason \(ML\) is interesting is because its form is basic but adapts to the data itself. For example, a simple neural network &#40;in design matrix form&#41; with sigmoid activation functions is simply matrix multiplications followed by application of sigmoid functions. Specifically,  \[ML(x)=\sigma(W_{3}\cdot\sigma(W_{2}\cdot\sigma(W_{1}\cdot x)))\] is a three-layer deep neural network, where \(W=(W_1,W_2,W_3)\) are learnable parameters. You then choose \(W\) such that \(ML(x)=y\) reasonably fits the function you wanted it to fit. The theory and practice of machine learning confirms that this is a good way to learn nonlinearities. For example, the Universal Approximation Theorem states that, for enough layers or enough parameters &#40;i.e. sufficiently large \(W_{i}\) matrices&#41;, \(ML(x)\) can approximate any nonlinear function sufficiently close &#40;subject to common constraints&#41;.</p>
<p>So great, this always works&#33; But it has some caveats, the main being that it has to learn everything about the nonlinear transform directly from the data. In many cases we do not know the full nonlinear equation, but we may know details about its structure. For example, the nonlinear function could be the population of rabbits in the forest, and we might know that their rate of births is dependent on the current population. Thus instead of starting from nothing, we may want to use this known <em>a priori</em> relation and a set of parameters that defines it. For the rabbits, let&#39;s say that we want to learn</p>
\[\text{rabbits tomorrow} = \text{Model}(\text{rabbits today}).\]
<p>In this case, we have prior knowledge of the rate of births being dependent on the current population. The way to mathematically state this structural assumption is via a differential equation. Here, what we are saying is that the birth rate of the rabbit population at a given time point increases when we have more rabbits. The simplest way of encoding that is</p>
\[\text{rabbits}'(t) = \alpha\cdot \text{rabbits}(t)\]
<p>where \(\alpha\) is some learnable constant. If you know your calculus, the solution here is exponential growth from the starting point with a growth rate \(\alpha\): \(\text{rabbits}(t_\text{start})e^{(\alpha t)}\). But notice that we didn&#39;t need to know the solution to the differential equation to validate the idea: we encoded the structure of the model and mathematics itself then outputs what the solution should be. Because of this, differential equations have been the tool of choice in most science. For example, physical laws tell you how electrical quantities emit forces &#40;<a href="https://en.wikipedia.org/wiki/Maxwell&#37;27s_equations">Maxwell&#39;s Equations</a>&#41;. These are essentially equations of how things change and thus &quot;where things will be&quot; is the solution to a differential equation. But in recent decades this application has gone much further, with fields like systems biology learning about cellular interactions by encoding known biological structures and mathematically enumerating our assumptions or in targeted drug dosage through PK/PD modelling in systems pharmacology.</p>
<p>So as our machine learning models grow and are hungry for larger and larger amounts of data, differential equations have become an attractive option for specifying nonlinearities in a learnable &#40;via the parameters&#41; but constrained form. They are essentially a way of incorporating prior domain-specific knowledge of the structural relations between the inputs and outputs. Given this way of looking at the two, both methods trade off advantages and disadvantages, making them complementary tools for modeling. It seems like a clear next step in scientific practice to start putting them together in new and exciting ways&#33;</p>
<h2 id="what_is_the_neural_ordinary_differential_equation_ode"><a href="/pub/blog/2019-01-18-fluxdiffeq.html#what_is_the_neural_ordinary_differential_equation_ode">What is the Neural Ordinary Differential Equation &#40;ODE&#41;?</a></h2>
<p>The neural ordinary differential equation is one of many ways to put these two subjects together. The simplest way of explaining it is that, instead of learning the nonlinear transformation directly, we wish to learn the structures of the nonlinear transformation. Thus instead of doing \(y=ML(x)\), we put the machine learning model on the derivative, \(y'(x) = ML(x)\), and now solve the ODE. Why would you ever do this? Well, one motivation is that defining the model in this way and then solving the ODE using the simplest and most error prone method, the Euler method, what you get is equivalent to a <a href="https://arxiv.org/abs/1512.03385">residual neural network</a>. The way the Euler method works is based on the fact that \(y'(x) = \frac{dy}{dx}\), thus</p>
\[\Delta y = (y_\text{next} - y_\text{prev}) = \Delta x\cdot ML(x)\]
<p>which implies that</p>
\[y_{i+1} = y_{i} + \Delta x\cdot ML(x_{i}).\]
<p>This looks similar in structure to a ResNet, one of the most successful image processing models. The insight of the the Neural ODEs paper was that increasingly deep and powerful ResNet-like models effectively approximate a kind of &quot;infinitely deep&quot; model as each layer tends to zero. Rather than adding more layers, we can just model the differential equation directly and then solve it using a purpose-built ODE solver. Numerical ODE solvers are a science that goes all the way back to the first computers, and modern ones can adaptively choose step sizes \(\Delta x\) and use high order approximations to drastically reduce the number of actual steps required. And as it turns out, this works well in practice, too.</p>
<h2 id="how_do_you_solve_an_ode"><a href="/pub/blog/2019-01-18-fluxdiffeq.html#how_do_you_solve_an_ode">How do you solve an ODE?</a></h2>
<p>First, how do you numerically specify and solve an ODE? If you&#39;re new to solving ODEs, you may want to watch our <a href="https://www.youtube.com/watch?v&#61;KPEqYtEd-zY">video tutorial on solving ODEs in Julia</a> and look through the <a href="http://docs.juliadiffeq.org/latest/tutorials/ode_example.html">ODE tutorial of the DifferentialEquations.jl documentation</a>. The idea is that you define an <code>ODEProblem</code> via a derivative equation <code>u&#39;&#61;f&#40;u,p,t&#41;</code>, and provide an initial condition <code>u0</code>, and a timespan <code>tspan</code> to solve over, and specify the parameters <code>p</code>.</p>
<p>For example, the <a href="https://en.wikipedia.org/wiki/Lotka&#37;E2&#37;80&#37;93Volterra_equations">Lotka-Volterra equations describe the dynamics of the population of rabbits and wolves</a>. They can be written as:</p>
\[x^\prime = \alpha x + \beta x y\] \[y^\prime = -\delta y + \gamma x y\]
<p>and encoded in Julia like: <pre><code class="language-julia">using DifferentialEquations
function lotka_volterra(du,u,p,t)
  x, y = u
  α, β, δ, γ = p
  du[1] = dx = α*x - β*x*y
  du[2] = dy = -δ*y + γ*x*y
end
u0 = [1.0,1.0]
tspan = (0.0,10.0)
p = [1.5,1.0,3.0,1.0]
prob = ODEProblem(lotka_volterra,u0,tspan,p)</code></pre> Then to solve the differential equations, you can simply call <code>solve</code> on the <code>prob</code>: <pre><code class="language-julia">sol = solve(prob)
using Plots
plot(sol)</code></pre> <img src="https://user-images.githubusercontent.com/1814174/51388169-9a07f300-1af6-11e9-8c6c-83c41e81d11c.png" alt="LV Solution Plot" /></p>
<p>One last thing to note is that we can make our initial condition &#40;<code>u0</code>&#41; and time spans &#40;<code>tspans</code>&#41; to be functions of the parameters &#40;the elements of <code>p</code>&#41;. For example, we can define the <code>ODEProblem</code>:</p>
<pre><code class="language-julia">u0_f(p,t0) = [p[2],p[4]]
tspan_f(p) = (0.0,10*p[4])
p = [1.5,1.0,3.0,1.0]
prob = ODEProblem(lotka_volterra,u0_f,tspan_f,p)</code></pre>
<p>In this form, everything about the problem is determined by the parameter vector &#40;<code>p</code>, referred to as <code>θ</code> in associated literature&#41;. The utility of this will be seen later.</p>
<p>DifferentialEquations.jl has many powerful options for customising things like accuracy, tolerances, solver methods, events and more; check out <a href="http://docs.juliadiffeq.org/latest/">the docs</a> for more details on how to use it in more advanced ways.</p>
<h2 id="lets_put_an_ode_into_a_neural_net_framework"><a href="/pub/blog/2019-01-18-fluxdiffeq.html#lets_put_an_ode_into_a_neural_net_framework">Let&#39;s Put an ODE Into a Neural Net Framework&#33;</a></h2>
<p>To understand embedding an ODE into a neural network, let&#39;s look at what a neural network layer actually is. A layer is really just a <em>differentiable function</em> which takes in a vector of size <code>n</code> and spits out a new vector of size <code>m</code>. That&#39;s it&#33; Layers have traditionally been simple functions like matrix multiply, but in the spirit of <a href="https://julialang.org/blog/2018/12/ml-language-compiler">differentiable programming</a> people are increasingly experimenting with much more complex functions, such as ray tracers and physics engines.</p>
<p>Turns out that differential equations solvers fit this framework, too: A solve takes in some vector <code>p</code> &#40;which might include parameters like the initial starting point&#41;, and outputs some new vector, the solution. Moreover it&#39;s differentiable, which means we can put it straight into a larger differentiable program. This larger program can happily include neural networks, and we can keep using standard optimisation techniques like ADAM to optimise their weights.</p>
<p>DiffEqFlux.jl makes it convenient to do just this; let&#39;s take it for a spin. We&#39;ll start by solving an equation as before, without gradients.</p>
<pre><code class="language-julia">p = [1.5,1.0,3.0,1.0]
prob = ODEProblem(lotka_volterra,u0,tspan,p)
sol = solve(prob,Tsit5(),saveat=0.1)
A = sol[1,:] # length 101 vector</code></pre>
<p>Let&#39;s plot <code>&#40;t,A&#41;</code> over the ODE&#39;s solution to see what we got:</p>
<pre><code class="language-julia">plot(sol)
t = 0:0.1:10.0
scatter!(t,A)</code></pre>
<p><img src="https://user-images.githubusercontent.com/1814174/51388173-9c6a4d00-1af6-11e9-9878-3c585d3cfffe.png" alt="Data points plot" /></p>
<p>The most basic differential equation layer is <code>diffeq_rd</code>, which does the same thing with a slightly altered syntax. <code>diffeq_rd</code> takes in parameters <code>p</code> for the integrand, puts it in the differential equation defined by <code>prob</code>, and solves it with the chosen arguments &#40;solver, tolerance, etc&#41;. For example:</p>
<pre><code class="language-julia">using Flux, DiffEqFlux
diffeq_rd(p,prob,Tsit5(),saveat=0.1)</code></pre>
<p>The nice thing about <code>diffeq_rd</code> is that it takes care of the type handling necessary to make it compatible with the neural network framework &#40;here Flux&#41;. To show this, let&#39;s define a neural network with the function as our single layer, and then a loss function that is the squared distance of the output values from <code>1</code>. In Flux, this looks like:</p>
<pre><code class="language-julia">p = param([2.2, 1.0, 2.0, 0.4]) # Initial Parameter Vector
params = Flux.Params([p])

function predict_rd() # Our 1-layer neural network
  diffeq_rd(p,prob,Tsit5(),saveat=0.1)[1,:]
end

loss_rd() = sum(abs2,x-1 for x in predict_rd()) # loss function</code></pre>
<p>Now we tell Flux to train the neural network by running a 100 epoch to minimise our loss function &#40;<code>loss_rd&#40;&#41;</code>&#41; and thus obtain the optimized parameters:</p>
<pre><code class="language-julia">data = Iterators.repeated((), 100)
opt = ADAM(0.1)
cb = function () #callback function to observe training
  display(loss_rd())
  # using `remake` to re-create our `prob` with current parameters `p`
  display(plot(solve(remake(prob,p=Flux.data(p)),Tsit5(),saveat=0.1),ylim=(0,6)))
end

# Display the ODE with the initial parameter values.
cb()

Flux.train!(loss_rd, params, data, opt, cb = cb)</code></pre>
<p>The result of this is the animation shown at the top. <a href="https://github.com/FluxML/model-zoo/blob/da4156b4a9fb0d5907dcb6e21d0e78c72b6122e0/other/diffeq/ode.jl">This code can be found in the model-zoo</a></p>
<p>Flux finds the parameters of the neural network &#40;<code>p</code>&#41; which minimize the cost function, i.e. it trains the neural network: it just so happens that the forward pass of the neural network includes solving an ODE. Since our cost function put a penalty whenever the number of rabbits was far from 1, our neural network found parameters where our population of rabbits and wolves are both constant 1.</p>
<p>Now that we have solving ODEs as just a layer, we can add it anywhere. For example, the multilayer perceptron is written in Flux as</p>
<pre><code class="language-julia">m = Chain(
  Dense(28^2, 32, relu),
  Dense(32, 10),
  softmax)</code></pre>
<p>and if we had an appropriate ODE which took a parameter vector of the right size, we can stick it right in there:</p>
<pre><code class="language-julia">m = Chain(
  Dense(28^2, 32, relu),
  # this would require an ODE of 32 parameters
  p -> diffeq_rd(p,prob,Tsit5(),saveat=0.1)[1,:],
  Dense(32, 10),
  softmax)</code></pre>
<p>or we can stick it into a convolutional neural network, where the previous layers define the initial condition for the ODE:</p>
<pre><code class="language-julia">m = Chain(
  Conv((2,2), 1=>16, relu),
  x -> maxpool(x, (2,2)),
  Conv((2,2), 16=>8, relu),
  x -> maxpool(x, (2,2)),
  x -> reshape(x, :, size(x, 4)),
  x -> diffeq_rd(p,prob,Tsit5(),saveat=0.1,u0=x)[1,:],
  Dense(288, 10), softmax) |> gpu</code></pre>
<p>As long as you can write down the forward pass, we can take any parameterised, differentiable program and optimise it. The world is your oyster.</p>
<h2 id="why_is_a_full_ode_solver_suite_necessary_for_doing_this_well"><a href="/pub/blog/2019-01-18-fluxdiffeq.html#why_is_a_full_ode_solver_suite_necessary_for_doing_this_well">Why is a full ODE solver suite necessary for doing this well?</a></h2>
<p>Where we have combined an existing solver suite and deep learning library, the excellent <a href="https://github.com/rtqichen/torchdiffeq">torchdiffeq</a> project takes an alternative approach, instead implementing solver methods directly in PyTorch, including an adaptive Runge Kutta 4-5 &#40;<code>dopri5</code>&#41; and an Adams-Bashforth-Moulton method &#40;<code>adams</code>&#41;. However, while their approach is very effective for certain kinds of models, not having access to a full solver suite is limiting.</p>
<p>Consider the following example, the <a href="https://www.radford.edu/~thompson/vodef90web/problems/demosnodislin/Single/DemoRobertson/demorobertson.pdf">ROBER ODE</a>. The most well-tested &#40;and optimized&#41; implementation of an Adams-Bashforth-Moulton method is the <a href="https://computation.llnl.gov/projects/sundials">CVODE integrator in the C&#43;&#43; package SUNDIALS</a> &#40;a derivative of the classic LSODE&#41;. Let&#39;s use DifferentialEquations.jl to call CVODE with its Adams method and have it solve the ODE for us:</p>
<pre><code class="language-julia">rober = @ode_def Rober begin
  dy₁ = -k₁*y₁+k₃*y₂*y₃
  dy₂ =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃
  dy₃ =  k₂*y₂^2
end k₁ k₂ k₃
prob = ODEProblem(rober,[1.0;0.0;0.0],(0.0,1e11),(0.04,3e7,1e4))
solve(prob,CVODE_Adams())</code></pre>
<p>&#40;For those familiar with solving ODEs in MATLAB, this is similar to <code>ode113</code>&#41;</p>
<p>Both this and the <code>dopri</code> method from <a href="https://www.unige.ch/~hairer/software.html">Ernst Hairer&#39;s Fortran Suite</a> stall and fail to solve the equation. This happens because the ODE is <a href="https://en.wikipedia.org/wiki/Stiff_equation">stiff</a>, and thus methods with &quot;smaller stability regions&quot; will not be able to solve it appropriately &#40;for more details, I suggest reading Hairer&#39;s Solving Ordinary Differential Equations II&#41;. On the other hand <code>KenCarp4&#40;&#41;</code> to this problem, the equation is solved in a blink of an eye:</p>
<pre><code class="language-julia">sol = solve(prob,KenCarp4())
using Plots
plot(sol,xscale=:log10,tspan=(0.1,1e11))</code></pre>
<p><img src="https://user-images.githubusercontent.com/1814174/51388944-eb18e680-1af8-11e9-874f-09478759596e.png" alt="ROBER Plot" /></p>
<p>This is just one example of subtlety in integration: Stabilizing explicit methods via PI-adaptive controllers, step prediction in implicit solvers, etc. are all intricate details that take a lot of time and testing to become efficient and robust. Different problems require different methods: <a href="http://docs.juliadiffeq.org/latest/solvers/dynamical_solve.html#Symplectic-Integrators-1">Symplectic integrators</a> are required to <a href="https://scicomp.stackexchange.com/questions/29149/what-does-symplectic-mean-in-reference-to-numerical-integrators-and-does-scip/29154#29154">adequately handle physical many problems without drift</a>, and tools like <a href="http://docs.juliadiffeq.org/latest/solvers/split_ode_solve.html#Implicit-Explicit-&#40;IMEX&#41;-ODE-1">IMEX integrators</a> are required to handle ODEs which <a href="https://www.youtube.com/watch?v&#61;okGybBmihOE">come from partial differential equations</a>. Building a production-quality solver is thus an enormous undertaking and relatively few exist.</p>
<p>Rather than building an ML-specific solver suite in parallel to one suitable for scientific computing, in Julia they are one and the same, meaning you can take advantage of all of these methods today.</p>
<h2 id="what_kinds_of_differential_equations_are_there"><a href="/pub/blog/2019-01-18-fluxdiffeq.html#what_kinds_of_differential_equations_are_there">What kinds of differential equations are there?</a></h2>
<p>Ordinary differential equations are only one kind of differential equation. There are many additional features you can add to the structure of a differential equation. For example, the amount of bunnies in the future isn&#39;t dependent on the number of bunnies right now because it takes a non-zero amount of time for a parent to come to term after a child is incepted. Thus the birth rate of bunnies is actually due to the amount of bunnies in the past. Using a lag term in a differential equation&#39;s derivative makes this equation known as a delay differential equation &#40;DDE&#41;. Since <a href="http://docs.juliadiffeq.org/latest/tutorials/dde_example.html">DifferentialEquations.jl handles DDEs</a> through the same interface as ODEs, it can be used as a layer in Flux as well. Here&#39;s an example:</p>
<pre><code class="language-julia">function delay_lotka_volterra(du,u,h,p,t)
  x, y = u
  α, β, δ, γ = p
  du[1] = dx = (α - β*y)*h(p,t-0.1)[1]
  du[2] = dy = (δ*x - γ)*y
end
h(p,t) = ones(eltype(p),2)
prob = DDEProblem(delay_lotka_volterra,[1.0,1.0],h,(0.0,10.0),constant_lags=[0.1])

p = param([2.2, 1.0, 2.0, 0.4])
params = Flux.Params([p])
function predict_rd_dde()
  diffeq_rd(p,prob,MethodOfSteps(Tsit5()),saveat=0.1)[1,:]
end
loss_rd_dde() = sum(abs2,x-1 for x in predict_rd_dde())
loss_rd_dde()</code></pre>
<p>The full code for this example, including generating an animation, <a href="https://github.com/FluxML/model-zoo/blob/da4156b4a9fb0d5907dcb6e21d0e78c72b6122e0/other/diffeq/dde.jl">can be found in the model-zoo</a></p>
<p>Additionally we can add randomness to our differential equation to simulate how random events can cause extra births or more deaths than expected. This kind of equation is known as a stochastic differential equation &#40;SDE&#41;. Since <a href="http://docs.juliadiffeq.org/latest/tutorials/sde_example.html">DifferentialEquations.jl handles SDEs</a> &#40;and is currently the only library with adaptive stiff and non-stiff SDE integrators&#41;, these can be handled as a layer in Flux similarly. Here&#39;s a neural net layer with an SDE:</p>
<pre><code class="language-julia">function lotka_volterra_noise(du,u,p,t)
  du[1] = 0.1u[1]
  du[2] = 0.1u[2]
end
prob = SDEProblem(lotka_volterra,lotka_volterra_noise,[1.0,1.0],(0.0,10.0))

p = param([2.2, 1.0, 2.0, 0.4])
params = Flux.Params([p])
function predict_fd_sde()
  diffeq_fd(p,sol->sol[1,:],101,prob,SOSRI(),saveat=0.1)
end
loss_fd_sde() = sum(abs2,x-1 for x in predict_fd_sde())
loss_fd_sde()</code></pre>
<p>And we can train the neural net to watch it in action and find parameters to make the amount of bunnies close to constant:</p>
<pre><code class="language-julia">data = Iterators.repeated((), 100)
opt = ADAM(0.1)
cb = function ()
  display(loss_fd_sde())
  display(plot(solve(remake(prob,p=Flux.data(p)),SOSRI(),saveat=0.1),ylim=(0,6)))
end

# Display the ODE with the current parameter values.
cb()

Flux.train!(loss_fd_sde, params, data, opt, cb = cb)</code></pre>
<p><img src="https://user-images.githubusercontent.com/1814174/51399524-2c6abf80-1b14-11e9-96ae-0192f7debd03.gif" alt="SDE NN Animation" /></p>
<p><a href="https://github.com/FluxML/model-zoo/blob/da4156b4a9fb0d5907dcb6e21d0e78c72b6122e0/other/diffeq/sde.jl">This code can be found in the model-zoo</a></p>
<p>And we can keep going. There are differential equations <a href="http://docs.juliadiffeq.org/latest/tutorials/discrete_stochastic_example.html">which are piecewise constant</a> used in biological simulations, or <a href="http://docs.juliadiffeq.org/latest/tutorials/jump_diffusion.html">jump diffusion equations from financial models</a>, and the solvers map right over to the Flux neural network framework through DiffEqFlux.jl. DiffEqFlux.jl uses only around ~100 lines of code to pull this all off.</p>
<h2 id="implementing_the_neural_ode_layer_in_julia"><a href="/pub/blog/2019-01-18-fluxdiffeq.html#implementing_the_neural_ode_layer_in_julia">Implementing the Neural ODE layer in Julia</a></h2>
<p>Let&#39;s go all the way back for a second and now implement the neural ODE layer in Julia. Remember that this is simply an ODE where the derivative function is defined by a neural network itself. To do this, let&#39;s first define the neural net for the derivative. In Flux, we can define a multilayer perceptron with 1 hidden layer and a <code>tanh</code> activation function like:</p>
<pre><code class="language-julia">dudt = Chain(Dense(2,50,tanh),Dense(50,2))</code></pre>
<p>To define a <code>neural_ode</code> layer, we then just need to give it a timespan and use the <code>neural_ode</code> function:</p>
<pre><code class="language-julia">tspan = (0.0f0,25.0f0)
x->neural_ode(dudt,x,tspan,Tsit5(),saveat=0.1)</code></pre>
<p>As a side note, to run this on the GPU, it is sufficient to make the initial condition and neural network be on the GPU. This will cause the entire ODE solver&#39;s internal operations to take place on the GPU without extra data transfers in the integration scheme. This looks like:</p>
<pre><code class="language-julia">x->neural_ode(gpu(dudt),gpu(x),tspan,Tsit5(),saveat=0.1)</code></pre>
<h2 id="understanding_the_neural_ode_layer_behavior_by_example"><a href="/pub/blog/2019-01-18-fluxdiffeq.html#understanding_the_neural_ode_layer_behavior_by_example">Understanding the Neural ODE layer behavior by example</a></h2>
<p>Now let&#39;s use the neural ODE layer in an example to find out what it means. First, let&#39;s generate a time series of an ODE at evenly spaced time points. We&#39;ll use the test equation from the Neural ODE paper.</p>
<pre><code class="language-julia">u0 = Float32[2.; 0.]
datasize = 30
tspan = (0.0f0,1.5f0)

function trueODEfunc(du,u,p,t)
    true_A = [-0.1 2.0; -2.0 -0.1]
    du .= ((u.^3)'true_A)'
end
t = range(tspan[1],tspan[2],length=datasize)
prob = ODEProblem(trueODEfunc,u0,tspan)
ode_data = Array(solve(prob,Tsit5(),saveat=t))</code></pre>
<p>Now let&#39;s pit a neural ODE against this data. To do so, we will define a single layer neural network which just has the same neural ODE as before &#40;but lower the tolerances to help it converge closer, makes for a better animation&#33;&#41;:</p>
<pre><code class="language-julia">dudt = Chain(x -> x.^3,
             Dense(2,50,tanh),
             Dense(50,2))
ps = Flux.params(dudt)
n_ode = x->neural_ode(dudt,x,tspan,Tsit5(),saveat=t,reltol=1e-7,abstol=1e-9)</code></pre>
<p>Notice that the <code>neural_ode</code> has the same timespan and <code>saveat</code> as the solution that generated the data. This means that given an <code>x</code> &#40;and initial value&#41;, it will generate a guess for what it thinks the time series will be where the dynamics &#40;the structure&#41; is predicted by the internal neural network. Let&#39;s see what time series it gives before we train the network. Since the ODE has two-dependent variables, we will simplify the plot by only showing the first. The code for the plot is:</p>
<pre><code class="language-julia">pred = n_ode(u0) # Get the prediction using the correct initial condition
scatter(t,ode_data[1,:],label="data")
scatter!(t,Flux.data(pred[1,:]),label="prediction")</code></pre>
<p><img src="https://user-images.githubusercontent.com/1814174/51585822-d9449400-1ea8-11e9-8665-956a16e95207.png" alt="Neural ODE Start" /></p>
<p>But now let&#39;s train our neural network. To do so, define a prediction function like before, and then define a loss between our prediction and data:</p>
<pre><code class="language-julia">function predict_n_ode()
  n_ode(u0)
end
loss_n_ode() = sum(abs2,ode_data .- predict_n_ode())</code></pre>
<p>And now we train the neural network and watch as it learns how to predict our time series:</p>
<pre><code class="language-julia">data = Iterators.repeated((), 1000)
opt = ADAM(0.1)
cb = function () #callback function to observe training
  display(loss_n_ode())
  # plot current prediction against data
  cur_pred = Flux.data(predict_n_ode())
  pl = scatter(t,ode_data[1,:],label="data")
  scatter!(pl,t,cur_pred[1,:],label="prediction")
  display(plot(pl))
end

# Display the ODE with the initial parameter values.
cb()

Flux.train!(loss_n_ode, ps, data, opt, cb = cb)</code></pre>
<p><img src="https://user-images.githubusercontent.com/1814174/51585825-dc3f8480-1ea8-11e9-8498-18cf55fba3e6.gif" alt="Neural ODE Train" /></p>
<p><a href="https://github.com/FluxML/model-zoo/blob/da4156b4a9fb0d5907dcb6e21d0e78c72b6122e0/other/diffeq/neural_ode.jl">This code can be found in the model-zoo</a></p>
<p>Notice that we are not learning a solution to the ODE. Instead, what we are learning is the tiny ODE system from which the ODE solution is generated. I.e., the neural network inside the neural_ode layer learns this function:</p>
<p>Thus <strong>it learned a compact representation of how the time series works</strong>, and it can easily extrapolate to what would happen with different starting conditions. Not only that, it&#39;s a very flexible method for learning such representations. For example, if your data is unevenly spaced at time points <code>t</code>, just pass in <code>saveat&#61;t</code> and the ODE solver takes care of it.</p>
<p>As you could probably guess by now, the DiffEqFlux.jl has all kinds of extra related goodies like Neural SDEs &#40;<code>neural_msde</code>&#41; for you to explore in your applications.</p>
<h2 id="the_core_technical_challenge_backpropagation_through_differential_equation_solvers"><a href="/pub/blog/2019-01-18-fluxdiffeq.html#the_core_technical_challenge_backpropagation_through_differential_equation_solvers">The core technical challenge: backpropagation through differential equation solvers</a></h2>
<p>Let&#39;s end by explaining the technical issue that needed a solution to make this all possible. The core to any neural network framework is the ability to backpropagate derivatives in order to calculate the gradient of the loss function with respect to the network&#39;s parameters. Thus if we stick an ODE solver as a layer in a neural network, we need to backpropagate through it.</p>
<p>There are multiple ways to do this. The most common is known as &#40;adjoint&#41; sensitivity analysis. Sensitivity analysis defines a new ODE whose solution gives the gradients to the cost function w.r.t. the parameters, and solves this secondary ODE. This is the method discussed in the neural ordinary differential equations paper, but actually dates back much further, and popular ODE solver frameworks like <a href="http://people.cs.vt.edu/~asandu/Software/FATODE/index.html">FATODE</a>, <a href="https://web.casadi.org/">CASADI</a>, and <a href="https://computation.llnl.gov/projects/sundials/cvodes">CVODES</a> have been available with this adjoint method for a long time &#40;CVODES came out in 2005&#33;&#41;. <a href="http://docs.juliadiffeq.org/latest/analysis/sensitivity.html">DifferentialEquations.jl has sensitivity analysis implemented too</a></p>
<p>The efficiency problem with adjoint sensitivity analysis methods is that they require multiple forward solutions of the ODE. As you would expect, this is very costly. Methods like the checkpointing scheme in CVODES reduce the cost by saving closer time points to make the forward solutions shorter at the cost of using more memory. The method in the neural ordinary differential equations paper tries to eliminate the need for these forward solutions by doing a backwards solution of the ODE itself along with the adjoints. The issue with this is that this method implicitly makes the assumption that the ODE integrator is <a href="https://www.physics.drexel.edu/~valliere/PHYS305/Diff_Eq_Integrators/time_reversal/">reversible</a>. Sadly, there are no reversible adaptive integrators for first-order ODEs, so with no ODE solver method is this guaranteed to work. For example, here&#39;s a quick equation where a backwards solution to the ODE using the Adams method from the paper has &gt;1700&#37; error in its final point, even with solver tolerances of 1e-12:</p>
<pre><code class="language-julia">using Sundials, DiffEqBase
function lorenz(du,u,p,t)
 du[1] = 10.0*(u[2]-u[1])
 du[2] = u[1]*(28.0-u[3]) - u[2]
 du[3] = u[1]*u[2] - (8/3)*u[3]
end
u0 = [1.0;0.0;0.0]
tspan = (0.0,100.0)
prob = ODEProblem(lorenz,u0,tspan)
sol = solve(prob,CVODE_Adams(),reltol=1e-12,abstol=1e-12)
prob2 = ODEProblem(lorenz,sol[end],(100.0,0.0))
sol = solve(prob,CVODE_Adams(),reltol=1e-12,abstol=1e-12)
@show sol[end]-u0 #[-17.5445, -14.7706, 39.7985]</code></pre>
<p>&#40;Here we once again use the CVODE C&#43;&#43; solvers from SUNDIALS since they are a close match to the SciPy integrators used in the neural ODE paper.&#41;</p>
<p>This inaccuracy is the reason why the method from the neural ODE paper is not implemented in software suites, but it once again highlights a detail. Not all ODEs will have a large error due to this issue. And for ODEs where it&#39;s not a problem, this will be the most efficient way to do adjoint sensitivity analysis. And this method only applies to ODEs. Not only that, it doesn&#39;t even apply to all ODEs. For example, ODEs with discontinuities &#40;<a href="http://docs.juliadiffeq.org/latest/features/callback_functions.html">events</a>&#41; are excluded by the assumptions of the derivation. Thus once again we arrive at the conclusion that one method is not enough.</p>
<p>In DifferentialEquations.jl have implemented many different methods for computing the derivatives of differential equations with respect to parameters. We have a <a href="https://arxiv.org/abs/1812.01892">recent preprint</a> detailing some of these results. One of the things we have found is that direct use of automatic differentiation can be one of the most efficient and flexible methods. Julia&#39;s ForwardDiff.jl, Flux, and ReverseDiff.jl can directly be applied to perform automatic differentiation on the native Julia differential equation solvers themselves, and this can increase performance while giving new features. Our findings show that forward-mode automatic differentiation is fastest when there are less than 100 parameters in the differential equations, and that for &gt;100 number of parameters adjoint sensitivity analysis is the most efficient. Even then, we have good reason to believe that <a href="https://julialang.org/blog/2018/12/ml-language-compiler">the next generation reverse-mode automatic differentiation via source-to-source AD, Zygote.jl</a>, will be more efficient than all of the adjoint sensitivity implementations for large numbers of parameters.</p>
<p>Altogether, being able to switch between different gradient methods without changing the rest of your code is crucial for having a scalable, optimized, and maintainable framework for integrating differential equations and neural networks. And this is precisely what DiffEqFlux.jl gives the user direct access to. There are three functions with a similar API:</p>
<ul>
<li><p><code>diffeq_rd</code> uses Flux&#39;s reverse-mode AD through the differential equation solver.</p>
</li>
<li><p><code>diffeq_fd</code> uses ForwardDiff.jl&#39;s forward-mode AD through the differential equation solver.</p>
</li>
<li><p><code>diffeq_adjoint</code> uses adjoint sensitivity analysis to &quot;backprop the ODE solver&quot;</p>
</li>
</ul>
<p>Therefore, to switch from a reverse-mode AD layer to a forward-mode AD layer, one simply has to change a single character. Since Julia-based automatic differentiation works on Julia code, the native Julia differential equation solvers will continue to benefit from advances in this field.</p>
<h2 id="conclusion"><a href="/pub/blog/2019-01-18-fluxdiffeq.html#conclusion">Conclusion</a></h2>
<p>Machine learning and differential equations are destined to come together due to their complementary ways of describing a nonlinear world. In the Julia ecosystem we have merged the differential equation and deep learning packages in such a way that new independent developments in the two domains can directly be used together. We are only beginning to understand the possibilities that have opened up with this software. We hope that future blog posts will detail some of the cool applications which mix the two disciplines, such as embedding our coming pharmacometric simulation engine <a href="https://doi.org/10.1007/s10928-018-9606-9">PuMaS.jl</a> into the deep learning framework. With access to the full range of solvers for ODEs, SDEs, DAEs, DDEs, PDEs, discrete stochastic equations, and more, we are interested to see what kinds of next generation neural networks you will build with Julia.</p>
<p>Note: a citable version of this post is published on <a href="https://arxiv.org/abs/1902.02376">Arxiv</a>.</p>
<pre><code class="language-julia">@article{DBLP:journals/corr/abs-1902-02376,
  author    = {Christopher Rackauckas and
               Mike Innes and
               Yingbo Ma and
               Jesse Bettencourt and
               Lyndon White and
               Vaibhav Dixit},
  title     = {DiffEqFlux.jl - {A} Julia Library for Neural Differential Equations},
  journal   = {CoRR},
  volume    = {abs/1902.02376},
  year      = {2019},
  url       = {http://arxiv.org/abs/1902.02376},
  archivePrefix = {arXiv},
  eprint    = {1902.02376},
  timestamp = {Tue, 21 May 2019 18:03:36 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/corr/abs-1902-02376},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}</code></pre></p>

<head>
  <meta name="description" content="We thank our contributors, donators, and Fastly for their support in keeping the Julia Language going. Donate here to help pay for Julia's needs."/>
</head>

<footer class="container-fluid footer-copy">
    <div class="container">
      <div class="row">
        <div class="col-md-10 py-2">
          <p>
            We thank <a style="color: #7a95dd" href="https://www.fastly.com">Fastly</a> for their generous infrastructure support. Donations help pay for community resources such as CI, Discourse, workshops, travel, JuliaCon, and other such needs.
          </p>
          <p>
            ©2020-01-19 JuliaLang.org contributors. The website content uses the <a style="color: #7a95dd" href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT license</a>.
          </p>
        </div>
        <div class="col-md-2 py-2">
          <a class="btn btn-success" href="https://numfocus.org/donate-to-julia">Donate</a>
        </div>
      </div>
    </div>
</footer>

</div>
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    
    <script src="/assets/v2/js/jquery.min.js"></script>
<script src="/assets/v2/js/bootstrap.min.js"></script>
<script src="/assets/v2/js/platform.js"></script>
<script src="/assets/v2/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script async defer src="https://buttons.github.io/buttons.js"></script>

  </body>
</html>
